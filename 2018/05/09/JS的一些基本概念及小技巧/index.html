<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript的一些概念及技巧"><meta name="keywords" content="ES6,JS,异步"><meta name="author" content="Luo Jun,undefined"><meta name="copyright" content="Luo Jun"><title>JavaScript的一些概念及技巧 | Aning</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.3"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JS的一些小知识点"><span class="toc-number">1.</span> <span class="toc-text">JS的一些小知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、变量声明提升"><span class="toc-number">1.1.</span> <span class="toc-text">一、变量声明提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">1.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用let取代var定义变量"><span class="toc-number">1.1.2.</span> <span class="toc-text">利用let取代var定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用函数作用域伪造局部作用域"><span class="toc-number">1.1.3.</span> <span class="toc-text">利用函数作用域伪造局部作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for循环中的变量提升"><span class="toc-number">1.1.4.</span> <span class="toc-text">for循环中的变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-number">1.1.5.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量寄存"><span class="toc-number">1.1.6.</span> <span class="toc-text">变量寄存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、函数声明提升"><span class="toc-number">1.2.</span> <span class="toc-text">二、函数声明提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用函数表达式来声明定义函数"><span class="toc-number">1.2.1.</span> <span class="toc-text">使用函数表达式来声明定义函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、const-常量"><span class="toc-number">1.3.</span> <span class="toc-text">三、const 常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、深浅拷贝"><span class="toc-number">1.4.</span> <span class="toc-text">四、深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型的深浅拷贝"><span class="toc-number">1.4.2.</span> <span class="toc-text">基本数据类型的深浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组的浅拷贝"><span class="toc-number">1.4.3.</span> <span class="toc-text">数组的浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组的深拷贝"><span class="toc-number">1.4.4.</span> <span class="toc-text">数组的深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用JSON序列化与反序列化深拷贝"><span class="toc-number">1.4.5.</span> <span class="toc-text">利用JSON序列化与反序列化深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、一些小技巧"><span class="toc-number">1.5.</span> <span class="toc-text">五、一些小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#两个变量值的交换"><span class="toc-number">1.5.1.</span> <span class="toc-text">两个变量值的交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组合并"><span class="toc-number">1.5.2.</span> <span class="toc-text">数组合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组去重"><span class="toc-number">1.5.3.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取数组中的最大值"><span class="toc-number">1.5.4.</span> <span class="toc-text">取数组中的最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用JS的隐式转换类型特性将字符串转为number"><span class="toc-number">1.5.5.</span> <span class="toc-text">利用JS的隐式转换类型特性将字符串转为number</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://wx4.sinaimg.cn/mw690/956c1201ly1fq8znagr59j20600600ue.jpg"></div><div class="author-info__name text-center">Luo Jun</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Aning</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">JavaScript的一些概念及技巧</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-05-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技术/">技术</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h1 id="JS的一些小知识点"><a href="#JS的一些小知识点" class="headerlink" title="JS的一些小知识点"></a>JS的一些小知识点</h1><h2 id="一、变量声明提升"><a href="#一、变量声明提升" class="headerlink" title="一、变量声明提升"></a>一、变量声明提升</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ES6之前的时代，声明变量常量用var关键字。但由于JS天生作用域机制的残缺，<code>不存在局部作用域</code>的概念，极容易发生<code>变量声明提升</code>为全局变量造成命名空间污染冲突等后果。<br>比较常见的解决方法是<code>利用函数作用域</code>来伪造局部作用域以隔绝变量间可能存在的冲突。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;x:&apos;, x)</span><br><span class="line">var x = 10;</span><br></pre></td></tr></table></figure>
<p>结果为: <img src="https://i.loli.net/2018/06/30/5b36fd66e0021.png" alt=""></p>
<p>即使是log(x)为undefined也是不符合常理的，<code>变量不能在未声明之前使用</code>一直是一个共通的编程规范。在某些静态类型的语言中如上的用法会导致解析器的报错。</p>
<p>而JS这里发生了<code>变量声明提升</code>,会将变量声明提升到文件头部,等同于如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line">console.log(&apos;x:&apos;, x)</span><br><span class="line">x = 10;</span><br></pre></td></tr></table></figure></p>
<h3 id="利用let取代var定义变量"><a href="#利用let取代var定义变量" class="headerlink" title="利用let取代var定义变量"></a>利用let取代var定义变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;x:&apos;, x)</span><br><span class="line">let x = 10;</span><br></pre></td></tr></table></figure>
<p>结果为：<img src="https://i.loli.net/2018/06/28/5b344a132f0df.png" alt=""></p>
<p>let声明定义的变量，不会发生变量声明提升，不能在被声明前使用，也不能在同一作用域内重复声明。</p>
<h3 id="利用函数作用域伪造局部作用域"><a href="#利用函数作用域伪造局部作用域" class="headerlink" title="利用函数作用域伪造局部作用域"></a>利用函数作用域伪造局部作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;x:&apos;, x)</span><br><span class="line">(() =&gt; &#123;</span><br><span class="line">  var x = 10;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>结果为：<img src="https://i.loli.net/2018/06/28/5b344a132f0df.png" alt=""></p>
<p>在局部作用域内定义声明的变量，即使是使用var声明定义，由于作用域间的相互隔绝，也不会污染其他作用域的命名空间。</p>
<hr>
<h3 id="for循环中的变量提升"><a href="#for循环中的变量提升" class="headerlink" title="for循环中的变量提升"></a>for循环中的变量提升</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">body&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    var oul = document.getElementsByTagName(&apos;ul&apos;)[0];</span><br><span class="line">    var oli = oul.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">    </span><br><span class="line">    for(var i = 0; i &lt; oli.length; i ++) &#123;</span><br><span class="line">      oli[i].onclick = function() &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码，按照我们通常的逻辑，每次点击li都会log出对应的i的值0, 1, 2, 3。然而每次log(i)的结果都为4。</p>
<p>为什么会这样呢?</p>
<p>首先，JS是由<code>事件驱动</code>的语言。上述代码中我们注册了四个点击事件，但是JS不知道该事件什么时候会发生,可能在未来的某个时刻，我们点击li元素触发。于是JS解释器会在解析完代码后将之放入内存。</p>
<ol>
<li>for循环中使用var定义的变量i会因为<code>变量提升</code>为<code>全局变量</code>。</li>
<li>在JS解释器解析完代码后，for循环亦也执行完毕了,那么<code>变量i</code>的值<code>已经是4</code>了。</li>
<li>因此，即使在未来的某个时刻我们点击了li元素，其中的i全部都指向全局变量i，所以值都为4。</li>
</ol>
<p>这就是一个典型的由于变量提升为全局变量所引发的命名空间污染所导致的逻辑与预期不符。</p>
<p>可以用如下的解决方式</p>
<ol>
<li>for循环中var改为let</li>
<li>闭包</li>
<li>变量寄存</li>
</ol>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>一个函数作用域内引用另一个作用域内的变量，只要该函数作用域没有消亡，该引用关系一直存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; oli.length; i ++) &#123;</span><br><span class="line">  (function(j) &#123;</span><br><span class="line">    oli[i].onclick = function() &#123;</span><br><span class="line">      console.log(j) // 代替轮播逻辑</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我这里使用了一个匿名函数(自执行函数)做了一个闭包，构造了一个由 <code>局部变量j</code>到<code>全局变量i</code>引用，j会一直保持着对<code>当时i</code>的引用(也可以说是利用每个函数作用域制造的局部作用域保存每个<code>当时i</code>的值)<br>什么叫做<code>当时</code>，在这里是执行每次的loop时i的值。如，第一次loop,i为0，第二次loop,i为1。</p>
<p>闭包的使用，会使与之引用的变量不能被垃圾回收机制所回收，使用频繁的话可能会有性能损耗。</p>
<h3 id="变量寄存"><a href="#变量寄存" class="headerlink" title="变量寄存"></a>变量寄存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; oli.length; i ++) &#123;</span><br><span class="line">  oli[i].index = i</span><br><span class="line">  oli[i].onclick = function() &#123;</span><br><span class="line">    console.log(this.index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>给每个li元素节点新增一个属性index寄存<code>当时i</code>的值，之后访问的也是新增的属性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了规避由var关键字带来的声明提升,所带来的全局命名空间的冲突混乱所造成的代码逻辑与预期不符，我们应尽量使用let关键字声明变量。</p>
<hr>
<h2 id="二、函数声明提升"><a href="#二、函数声明提升" class="headerlink" title="二、函数声明提升"></a>二、函数声明提升</h2><p><strong>函数声明同变量声明一样，也会发生<code>函数声明提升</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo() // 函数调用</span><br><span class="line"></span><br><span class="line">function foo() &#123; &#125;  // 函数声明</span><br></pre></td></tr></table></figure></p>
<p>虽然可以正常调用,但函数调用在函数声明前，一样的不符合流程规范违反直觉。</p>
<h3 id="使用函数表达式来声明定义函数"><a href="#使用函数表达式来声明定义函数" class="headerlink" title="使用函数表达式来声明定义函数"></a>使用函数表达式来声明定义函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let foo = function() &#123; &#125;;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>使用函数表达式来声明定义函数的话，如果调用在声明前，会报错。</p>
<hr>
<h2 id="三、const-常量"><a href="#三、const-常量" class="headerlink" title="三、const 常量"></a>三、const 常量</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>const 一般用来定义常量，何谓常量，便是当定义后，<code>所指向的地址</code>不会被更改的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a = 10;</span><br><span class="line">a = 11;</span><br></pre></td></tr></table></figure>
<p>报错: <img src="https://i.loli.net/2018/06/28/5b345c78abb42.png" alt=""></p>
<p>其实常量也是可以更改的，只要<code>常量所指向的地址</code>没有改变。</p>
<p>每个变量定义赋值，并不是单纯的只是赋值而已。而是会在内存中分配一个内存空间地址存储着这个值，变量再指向这个地址。</p>
<p>依据上面的原理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">arr[0] = 10</span><br></pre></td></tr></table></figure></p>
<p>为什么常量a更改后报错，而常量arr却可以更改？</p>
<p>因此对常量a的重新赋值会改变a所指向的内存地址，自然是违背了常量的规范了。</p>
<p>我们也可以改变arr的地址，给它赋值其他的基本数据类型或另一种引用数据类型(这样的话，arr会指向新的地址)。看一看这样的话会不会报错呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">arr = 2;</span><br></pre></td></tr></table></figure></p>
<p>结果：<img src="https://i.loli.net/2018/06/30/5b371cf5e0036.png" alt=""></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>JS中的number,string,boolean属于基本数据类型，由单个内存空间地址存储。</li>
<li>而数组[], object{}属于引用数据类型，会由连续的内存空间地址存储。</li>
<li>对基本数据类型重新赋值的话，又会开辟一个新的内存空间地址存储。</li>
<li>对引用数据类型如改变数组某个下标的的值，并不会开辟新的内存空间地址存储。</li>
</ol>
<p>tips: 其实这个概念很类似于C语言中的指针，指针便直接是对内存中的地址进行操作。</p>
<hr>
<h2 id="四、深浅拷贝"><a href="#四、深浅拷贝" class="headerlink" title="四、深浅拷贝"></a>四、深浅拷贝</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul>
<li>基本数据类型number，string，boolean的深拷贝与浅拷贝结果相同。</li>
<li>引用数据类型数组[], object{}的深拷贝与浅拷贝有显著区别。</li>
</ul>
<h3 id="基本数据类型的深浅拷贝"><a href="#基本数据类型的深浅拷贝" class="headerlink" title="基本数据类型的深浅拷贝"></a>基本数据类型的深浅拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = 10;</span><br><span class="line">let b = a;</span><br><span class="line"></span><br><span class="line">b = 12;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>
<p>变量a的值仍然为10，不会因为变量b的值更改而受到影响。</p>
<h3 id="数组的浅拷贝"><a href="#数组的浅拷贝" class="headerlink" title="数组的浅拷贝"></a>数组的浅拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 浅拷贝</span><br><span class="line">let a1 = [1, 2, 3];</span><br><span class="line">let a2 = a1;</span><br><span class="line"></span><br><span class="line">console.log(a1);</span><br><span class="line">a2[0] = 10;</span><br><span class="line">console.log(a1);</span><br></pre></td></tr></table></figure>
<p>结果: <img src="https://i.loli.net/2018/06/28/5b347a7203ce2.png" alt="FP$`ZGYOW9I713R0P3K}K46.png"></p>
<p>第一个log()a1中的值没有改变，当对a2[0]重新赋值后,a1竟然也改变了。</p>
<p>这就是数组的浅拷贝，所谓的a1赋值给a2，只是把这个<code>数组所在的内存空间地址</code>赋予了a2。于是a1与a2指向同一个地址，对a2进行操作自然会影响到a1。</p>
<h3 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 深拷贝-利用扩展运算符</span><br><span class="line">let a1 = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let a2 = [...a1]    // ES6</span><br><span class="line">// [].concat(a1)  || a1.slice()  ES5</span><br><span class="line"></span><br><span class="line">console.log(a1);</span><br><span class="line">a2[0] = 10;</span><br><span class="line">console.log(a1);</span><br></pre></td></tr></table></figure>
<p>结果：<img src="https://i.loli.net/2018/06/28/5b347cebc307b.png" alt=""></p>
<p>这样看来，深拷贝的目的确实达到了。但是，这种方法只会拷贝数组对象的第一层属性。第二层属性还是公用的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a1 = [1, 2, 3, [5, 6]];</span><br><span class="line">let a2 = [...a1];</span><br><span class="line"></span><br><span class="line">a2[0] = 10;</span><br><span class="line">a2[3][0] = 10;</span><br><span class="line">console.log(a1);</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><img src="https://i.loli.net/2018/06/28/5b347f93a1569.png" alt=""></p>
<p>数组a1第一层属性中的下标为0的值并没有改变,只有第二层属性(子数组[5,6])中的下标为0的值被改变为10了。<br>这样的话，扩展运算符对于深层属性的拷贝，并没有另外的开辟新地址存储，依然是地址引用的传值。</p>
<h3 id="利用JSON序列化与反序列化深拷贝"><a href="#利用JSON序列化与反序列化深拷贝" class="headerlink" title="利用JSON序列化与反序列化深拷贝"></a>利用JSON序列化与反序列化深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a1 = [1, 2, 3, [5, 6]]</span><br><span class="line">let a2 = JSON.parse(JSON.stringify(a1))</span><br><span class="line"></span><br><span class="line">a2[0] = 10</span><br><span class="line">a2[3][0] = 10</span><br><span class="line">console.log(a1)</span><br></pre></td></tr></table></figure>
<p>结果：<img src="https://i.loli.net/2018/06/28/5b3481f6d243c.png" alt=""></p>
<p>数组a1的第一层与第二层都没有改变，由此证明第二层属性的地址也独立开来了。</p>
<p>其实利用JSON的序列化与反序列化在某些极端情况下也并不能完全深拷贝，还有其他的一些如<code>递归拷贝</code>等实现深拷贝的方法。但各有缺点。</p>
<p>在大多数只需要拷贝一层属性的情况下，扩展运算符与JSON序列化都足够胜任。感兴趣的可以了解了解递归拷贝。</p>
<p><code>{}深浅拷贝情况与数组无异。</code></p>
<h2 id="五、一些小技巧"><a href="#五、一些小技巧" class="headerlink" title="五、一些小技巧"></a>五、一些小技巧</h2><h3 id="两个变量值的交换"><a href="#两个变量值的交换" class="headerlink" title="两个变量值的交换"></a>两个变量值的交换</h3><p>两个值的交换-利用ES6解构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure></p>
<h3 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h3><p>合并数组,合并对象同理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3, 4, 5]</span><br><span class="line">console.log([...a, 10, 11, 12])</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/06/28/5b348b4689cf7.png" alt=""></p>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>利用ES6中的Set结构类型特性，进行数组去重<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 1, 2, 3, 4, 4]</span><br><span class="line">console.log([...new Set(a)])</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/06/28/5b3486c018ba5.png" alt=""></p>
<h3 id="取数组中的最大值"><a href="#取数组中的最大值" class="headerlink" title="取数组中的最大值"></a>取数组中的最大值</h3><p>最大值-利用扩展运算符结合Math方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(...[3, 1, 2, 9, 1])</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/06/28/5b3487c460764.png" alt=""></p>
<p>最小值同理Math.min()</p>
<h3 id="利用JS的隐式转换类型特性将字符串转为number"><a href="#利用JS的隐式转换类型特性将字符串转为number" class="headerlink" title="利用JS的隐式转换类型特性将字符串转为number"></a>利用JS的隐式转换类型特性将字符串转为number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = -&apos;123.56&apos; // let a = +&apos;123.56&apos;</span><br><span class="line">console.log(a)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/06/28/5b348c1b284f0.png" alt=""></p>
<p>利用JS的隐式转换我们可以做很多事情，隐式转换有利有弊，褒贬不一。</p>
<p><img src="https://i.loli.net/2018/06/28/5b348e25006e3.png" alt=""></p>
<ul>
<li>空string，undefined，NaN，0都会隐式转换为false</li>
<li>需要注意的是空数组会转为true，<code>这是一个坑</code>。</li>
</ul>
<p>python中对空数组的隐式转换，会将空数组转为false。</p>
<p><img src="https://i.loli.net/2018/06/28/5b348f630d5a1.png" alt=""></p>
<p>not 逻辑运算符等同于JS中的“!”,也就是与或非中的非。</p>
<p>JS的隐式转换会经历一个颇为复杂的过程，详情可以<a href="https://segmentfault.com/p/1210000008572181/read" target="_blank" rel="noopener">看这里</a></p>
<ul>
<li><p>总而言之，可以适度使用，但不能滥用。</p>
</li>
<li><p>实际中，使用最多的应该是number与字符串的拼接,分支语句中的条件判断吧。</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Luo Jun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="/2018/05/09/JS的一些基本概念及小技巧/">/2018/05/09/JS的一些基本概念及小技巧/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="" target="_blank">Aning</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ES6/">ES6</a><a class="post-meta__tags" href="/tags/JS/">JS</a><a class="post-meta__tags" href="/tags/异步/">异步</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/05/09/promiseAndAsync/"><i class="fa fa-chevron-left">  </i><span>JavaScript的异步编程</span></a></div><div class="next-post pull-right"><a href="/2018/05/04/export/"><span>模块载入代码区别</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By Luo Jun</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>