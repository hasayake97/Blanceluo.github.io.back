<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript的异步进化"><meta name="keywords" content="ES6,JS,异步"><meta name="author" content="Luo Jun,undefined"><meta name="copyright" content="Luo Jun"><title>JavaScript的异步进化 | Aning</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.3"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript的异步进化"><span class="toc-number">1.</span> <span class="toc-text">JavaScript的异步进化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步"><span class="toc-number">1.1.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步"><span class="toc-number">1.2.</span> <span class="toc-text">异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS中的同步异步"><span class="toc-number">1.3.</span> <span class="toc-text">JS中的同步异步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进化1"><span class="toc-number">1.4.</span> <span class="toc-text">进化1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise-进化"><span class="toc-number">1.5.</span> <span class="toc-text">promise 进化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Async-Await-进化"><span class="toc-number">1.6.</span> <span class="toc-text">Async Await 进化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套"><span class="toc-number">1.6.1.</span> <span class="toc-text">嵌套</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://wx4.sinaimg.cn/mw690/956c1201ly1fq8znagr59j20600600ue.jpg"></div><div class="author-info__name text-center">Luo Jun</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container" style="background-image: url(true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Aning</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">JavaScript的异步进化</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技术/">技术</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h1 id="JavaScript的异步进化"><a href="#JavaScript的异步进化" class="headerlink" title="JavaScript的异步进化"></a>JavaScript的异步进化</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>便是在同一时间内，只能进行一个操作。</p>
<p>若有多个操作需要执行，则按顺序排列，前一个操作执行完成，再后一个操作接着执行。</p>
<p>稳定，安全，效率较低。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>在js中，异步并不需要等待当前任务的结束，便可以开始下一个任务，再利用之前任务的回调，继续执行之前任务。</p>
<p>快速，效率高，但如果要在异步操作中对同一个变量进行操作时，需要非常小心。</p>
<hr>
<h2 id="JS中的同步异步"><a href="#JS中的同步异步" class="headerlink" title="JS中的同步异步"></a>JS中的同步异步</h2><p>JS是<code>单线程</code>的，代码流是<code>从上而下</code>的执行。由一个主线程负责,此外还存在一个<code>任务队列</code>。</p>
<p>JS中的异步几乎都是通过<code>回调函数</code>实现，通过<code>任务队列</code>，在主线程执行完所有的任务(同步操作)完成后,便会<code>轮询(Event Loop)</code>任务队列，并将任务队列中的任务(回调函数)取出执行。</p>
<p>虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含下图中的3种 webAPI，分别是 DOM Binding、network、timer模块。<br><img src="https://i.loli.net/2018/06/14/5b21bab44a3e2.png" alt="B26QYABRUGGS64VFL}0_BC1.png"></p>
<p>如：<code>示例1</code></p>
<iframe width="100%" height="300" src="http://jsfiddle.net/y7dsjmu4/9/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>

<p><strong><code>由于使用的是console来展示结果, 需要打开浏览器的控制台，再切换到result页面才会执行代码以此看到结果,后面的都是如此。</code></strong></p>
<ul>
<li><p>若按一般思维，会先等待四秒log(1),再等待两秒log(2), 最后才是log(3)。</p>
</li>
<li><p>实际情况却是，首先log(3)，然后等待两秒log(2)，再等待两秒(<code>虽然第二个定时器delay为4s，不过这4s中有2s是与第一个定时器并行的</code>)，才是log(1)。</p>
</li>
</ul>
<p>为什么会是这样的情况，一步一步的剖析吧。</p>
<ol>
<li><p>首先，声明赋值了一个变量a的值为1。</p>
</li>
<li><p>遇到一个定时器，<code>开始计算delay</code>。</p>
</li>
<li><p>遇到一个定时器，<code>开始计算delay</code>。</p>
</li>
<li><p>最后遇到一个console.log(3)，直接输出。<code>主线程所有的任务（同步）操作执行完成，轮询任务队列</code>。</p>
</li>
<li><p>2s定时器的delay满足，推入任务队列。</p>
</li>
<li><p>4s定时器的delay满足，推入任务队列。</p>
</li>
</ol>
<p>tips：轮询不会只执行一次，顾名思义<code>轮流询问访问，按照一定的频率或者满足条件访问某种活动</code>。<br>每当主线程的所有任务执行完成，就会去轮询任务队列。这个过程会<code>不断重复</code>(该过程又被称为事件轮询)。</p>
<p>上面的代码，第五步定时器被推入任务队列时，<code>主线程中的任务早已执行完毕,任务队列早就处于被轮询的状态了</code>。所以一旦被推入任务队列，便被取出执行。第六步一样。</p>
<p><img src="https://i.loli.net/2018/06/14/5b21c9b0c1a8b.png" alt=""></p>
<p>注意，js解释器的效率是极其快的，从开始到主线程中的任务执行完毕，也就几毫秒的时间。</p>
<p>也就是说，<code>若主线程中的任务需要足够长的时间</code>(可以被我们人类感受到)，那么我们便可以感知得到任务队列中任务执行的推迟。</p>
<p>下面的代码我刻意的设置了一个loop以阻塞主线程，大约需要<code>十秒</code>左右主线程中的任务才会执行完毕。</p>
<p>若有兴趣，可以尝试以下代码。</p>
<p><strong><code>(这个loop的设置，小于这个上限达不到效果，大于的话浏览器可能崩溃)</code></strong></p>
<p>如：<code>示例2</code></p>
<p>请耐心等待十秒左右</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/09sqfg1b/51/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>

<p><img src="https://i.loli.net/2018/06/14/5b21cc3b1372b.png" alt=""></p>
<p>可以看出定时器的回调函数执行时间并不是设置的delay,于是我们发现当主线程的所需运行时间远远大于定时器的delay时，即使delay已经满足了,回调被推入任务队列，也要等到主线程中的所有任务完成，回调才会执行。</p>
<p><code>再次验证了必须得等到主线程的所有任务完成，任务队列才能开始被轮询,只有任务队列被轮询，任务队列中的任务(回调)才能有机会被取出执行。</code></p>
<p>即使loop相同，每次的到达时间也不尽相同,原因很多，如JS解释器解析代码的效率, 运行的环境，平台。</p>
<p>因此，假如将一个很费时的操作放入主线程，那么后果可能是会造成代码执行的阻塞，页面的无响应。</p>
<p>亦因此js推荐将所有的可能费时的操作放入任务队列而不是主线程中，主线程的代码执行速度才会如此之快。</p>
<p><code>示例3</code></p>
<iframe width="100%" height="300" src="http://jsfiddle.net/q9z8t6cs/7/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>


<p><code>页面可能一直处于繁忙未响应状态，甚至崩溃,连第一个log(在代码顺序中是最后一个)都出不来了。</code></p>
<p>当然，实际开发中是不可能有这么大的loop的。</p>
<p>如果再把这个loop放入任务队列中，第一个log便可以出来了<code>(因为第一个log在主线程中,并没有被阻塞)</code>。</p>
<p>但是任务队列可能就阻塞了，因为这个loop实在是太耗费性能了，而系统分配给浏览器的硬件资源是远不能胜任的。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p><code>JS是&#39;单线程&#39;的。</code></p>
</li>
<li><p><code>JS的代码流从上至下的执行，在遇到异步代码时,需要满足条件才能将回调推入任务队列。</code></p>
</li>
<li><p><code>只有当主线程中的任务都完成后，任务队列才能开始被轮询</code></p>
</li>
</ul>
<hr>
<h2 id="进化1"><a href="#进化1" class="headerlink" title="进化1"></a>进化1</h2><p>js异步实现，多是利用回调函数。</p>
<ol>
<li><p>定时器触发时间到达，回调推入任务队列。</p>
</li>
<li><p>ajax 请求响应返回，回调推入任务队列。</p>
</li>
<li><p>事件绑定，事件触发，回调推入任务队列。</p>
</li>
</ol>
<p>根据业务需求，假如回调函数中又有回调函数，嵌套层级过多，便出现了著名的“回调地狱”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">      url: xxx,</span><br><span class="line">      ...</span><br><span class="line">      success: function()&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">          ...</span><br><span class="line">          success: function()&#123;</span><br><span class="line">            ....</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>将之抽象,例如嵌套四次呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc1(opt, (...args1) =&gt; &#123;</span><br><span class="line">    asyncFunc2(opt, (...args2) =&gt; &#123;</span><br><span class="line">        asyncFunc3(opt, (...args3) =&gt; &#123;</span><br><span class="line">            asyncFunc4(opt, (...args4) =&gt; &#123;</span><br><span class="line">                // some operation</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">虽然我们可以将上述的ajax代码封装成一个函数调用，但本质仍然如上图所述。</span><br></pre></td></tr></table></figure></p>
<p>随着ES6的发展，出现了promise，Generator(生成器)等回调地狱的解决方案。<br>换句话说，我们可以使用另一种写法实现异步代码。比之前较为优美。</p>
<hr>
<h2 id="promise-进化"><a href="#promise-进化" class="headerlink" title="promise 进化"></a>promise 进化</h2><ol>
<li><p>Promise有三种状态</p>
<ul>
<li><p>Promise对象代表一个异步操作，三种状态分别是：Pending(进行中)，Resolved(已完成，又称Fulfilled)和Rejected(已失败)。</p>
</li>
<li><p>只有异步操作的结果(resolve(), reject()),可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      $.ajax(</span><br><span class="line">        url: xxx,</span><br><span class="line">        ...</span><br><span class="line">        success: function(res)&#123;</span><br><span class="line">          resolve(res)  // 这里resolve</span><br><span class="line">        &#125;,</span><br><span class="line">        err : function(err)&#123;</span><br><span class="line">          reject(err)   // 出错话则reject</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise.then((res) =&gt; &#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    ... // res形参是接收resolve的传值</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">  ....  // err形参是接收reject的传值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>Promise构造函数，参数可以是两个函数,resolve与reject,可选，命名也可以自定义只要位置对应。</p>
<p>根据业务需求，是resolve还是reject。</p>
<p><code>resolve()后，状态改为Resolved，进入promise.then()。</code></p>
<p><code>reject(),状态改为Rejected，进入promise.catch()</code>。</p>
<p><strong>resolve与reject都是异步的</strong></p>
<p><code>既然是异步，那么根据同步优先于异步的原则</code>下面的代码结果是多少呢?</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/vyr9au8L/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>

<p><strong>then与catch的组合</strong></p>
<p>then与catch的组合写法多种，个人比较推崇这一种。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// catch后跟在then</span><br></pre></td></tr></table></figure></p>
<p><code>实际情况下，catch比较少用。</code></p>
<p>Promise虽然比普通的回调看起来好了些，但如果嵌套层级过多，会造成链式调用过长，太过抽象，语义不明确。<br><img src="https://i.loli.net/2018/06/15/5b2317939af0f.png" alt=""></p>
<p>根据上图，我们可以写成链式调用的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promise.then()</span><br><span class="line">        .then()</span><br><span class="line">         .then()</span><br></pre></td></tr></table></figure>
<p><strong>为什么要嵌套?</strong></p>
<p><code>因为回调是异步的，若以同步写法是捕捉不到回调返回的值的，因此促使下一级必须写在上一级回调中才能实现依赖。</code></p>
<p>可以看看这个 </p>
<p><code>示例5</code></p>
<iframe width="100%" height="300" src="//jsfiddle.net/6fbL7x18/embedded/js,html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let v1 = &apos;123&apos;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &apos;http://v3.wufazhuce.com:8000/api/onelist/3528/0?channel=wdj&amp;version=4.0.2&amp;uuid=ffffffff-a90e-706a-63f7-ccf973aae5ee&amp;platform=android&apos;,  // 公共api</span><br><span class="line">  success: (res) =&gt; &#123;</span><br><span class="line">    v1 = res</span><br><span class="line">    console.log(&apos;inner step&apos;, v1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;out step&apos;, v1)</span><br><span class="line">... // 对v1的后续操作</span><br></pre></td></tr></table></figure>
<p>这是我之前亲身经历过类似的一个开发情境，代码简化了许多。变量v1要接收ajax响应成功后返回的res,之后再对v1进行处理(其实就是对res的操作)。但我对v1进行后续操作的代码是<code>写在ajax外的</code>。本以为它的值已经不再是’123’而是res了，以致于我最后得到的结果总是与预期大相径庭。console调试，发现v1的值在我进行后续操作时根本就没有发生改变还是’123’，想了想，原来是自己以同步的写法直觉来实现对异步数据的操作。</p>
<p>ajax的回调是<code>异步</code>的，代码流的从上而下执行根本就不会等待success回调后才继续，而是直接执行到外层out step了。所以在我对v1的后续操作前，根本就没有捕获到res，以致于结果与预期的差异。</p>
<p>所以我如果要等到v1 = res后才开始后续操作，那么必须得把后续操作都放在success的回调里进行才能保证代码如预期进行。</p>
<p>也便是经此开始，我才真正对js这门语言的异步机制有了兴趣与一些模糊概念，开始去有意了解它。</p>
<p>tips: <code>异步代码也存在优先级的情况，promise的优先级高于定时器。</code></p>
<p><code>示例6</code></p>
<iframe width="100%" height="300" src="http://jsfiddle.net/6n5gtwcs/1/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>

<p>阮老师的博客：<a href="http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html" target="_blank" rel="noopener">Node 定时器详解</a></p>
<hr>
<h2 id="Async-Await-进化"><a href="#Async-Await-进化" class="headerlink" title="Async Await 进化"></a>Async Await 进化</h2><p><strong><code>await必须只能在async函数体内使用</code></strong></p>
<p>生成器略过，promise与generator都是过渡。因为ES7有一个生成器Generator的语法糖Async，这被人们称为JS异步编程的最终实现。</p>
<p>对上面的<code>示例5</code>使用async重写，我现在可以把后续操作放在await的下一行开始了。</p>
<p><code>示例7</code></p>
<iframe width="100%" height="300" src="//jsfiddle.net/Lodb9v3y/7/embedded/js,html,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let v1 = &apos;123&apos;;</span><br><span class="line"></span><br><span class="line">let ajax1 = () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: &apos;http://v3.wufazhuce.com:8000/api/onelist/3528/0?channel=wdj&amp;version=4.0.2&amp;uuid=ffffffff-a90e-706a-63f7-ccf973aae5ee&amp;platform=android&apos;,</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  v1 = await ajax1()</span><br><span class="line">  console.log(v1)</span><br><span class="line">  ... // 对v1的后续操作</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>如果为了简洁美观，还可以再把后续操作封装成一个函数传参调用即可。</p>
<hr>
<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>// 首先我使用一个promise做一个<code>示例8</code>对比</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/v3h79e1u/14/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let ex = 10;</span><br><span class="line">    </span><br><span class="line">let pro = new Promise(resolve =&gt; &#123;</span><br><span class="line">  resolve(++ex)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pro</span><br><span class="line">  .then(msg =&gt; &#123;</span><br><span class="line">    return ++msg</span><br><span class="line"></span><br><span class="line">    /* 等同于</span><br><span class="line">     * return new Promise(resolve =&gt; &#123;</span><br><span class="line">     *  resolve(++msg)</span><br><span class="line">     * &#125;)</span><br><span class="line">     */</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(msg =&gt; &#123;</span><br><span class="line">    console.log(msg)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>简单的依赖雏形</p>
<ul>
<li><p>上面代码块里第二个then代码块里的msg2(++msg)必须依赖第一个then里的msg(++ex)。</p>
</li>
<li><p>操作都是建立的前一步操作的基础上。这就是一个依赖的雏形。</p>
</li>
</ul>
<p>tips: 自增++自减符–放置在变量的左边或者右边也是有区别的，但在这里没有任何差异。</p>
<p>现在我用async与await来实现</p>
<p><code>示例9</code></p>
<iframe width="100%" height="300" src="http://jsfiddle.net/3rwkbevq/1/embedded/js,result/" allowfullscreen="allowfullscreen" allowpaymentrequest="" frameborder="0"></iframe>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let ex = 10;</span><br><span class="line"></span><br><span class="line">let step1 = (ex) =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    resolve(++ex)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let step2 = (ex) =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    resolve(++ex)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">  let res = await step2(await step1(ex))</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// 这样的话,流程更加清晰</span><br><span class="line">// let tmp = await step1(ex)</span><br><span class="line">// let res = await step2(tmp)</span><br><span class="line"></span><br><span class="line">// 这样看来，用async实现异步代码的依赖根本就无需嵌套了，按同步直觉写法即可。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>await 一般<code>后跟一个promise对象</code>,否则的话await便没有意义使用了。</p>
</li>
<li><p>当在async函数内遇到await，由于await会<code>阻塞</code>当前所在的作用域(async函数作用域)，不会直接进行下一步，一直会在等待resolve()的返回才会继续下面代码的执行。</p>
</li>
</ul>
<p>这里只是告诉具体的流程思路，当然，如果在实际过程中只是对一个值进行两次的自增操作是完全不需要的。把自增操作替换成一个有依赖关系的多个回调呢？</p>
<ul>
<li><p>async await的异步代码编写方式，被称作js异步的最终解决方案，代表着一种未来的趋势。</p>
</li>
<li><p><code>JS异步写法的不断进化，本质仍是利用回调函数，进化是为了让人们可以同步的写法来实现异步，不仅是为了简化代码编写，还使得代码观感更贴近同步。直观，简洁，易于理解。</code></p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Luo Jun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="/2018/06/13/async/">/2018/06/13/async/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="" target="_blank">Aning</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ES6/">ES6</a><a class="post-meta__tags" href="/tags/JS/">JS</a><a class="post-meta__tags" href="/tags/异步/">异步</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2018/05/09/decorator/"><span>decorator</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By Luo Jun</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>